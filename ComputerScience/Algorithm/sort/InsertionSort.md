### 插入排序

>一般情况下，比冒泡快一倍，比选择稍快一些。常被用在较复杂排序算法的最后阶段。如：快速排序

##### 思路

>插入排序使用了增量方法：在排序子数组A[1.. j-1]之后，将单个元素A[ j ]插入子数组的适当位置，产生排序好的子数组A[1.. j]

* 保证局部有序：取某个元素为标记，标记左侧所有元素都是有序的;标记及其右侧都是无序的
* array[1]为初始标记pivot，遍历array与pivot比较。for outer in 1 until size
* array[i] < pivot, 则从此处开始向前迭代，将所有的大于pivot的元素向后移动一位
* 此时，pivot之前全部有序
* array[i] > pivot，则array[i]为新的pivot
* 从标记开始向前遍历，将标记插入到左侧有序的元素中，并将原旧标记后一个元素视为新标记

```
假设一组数据
1 | pivot : 40 | 20, 40, 30, 80, 70, 45, 60, 55, 89, 43

2 | pivot : 30 | 20, 40, 30, 80, 70, 45, 60, 55, 89, 43
2 | pivot : 30 | 20, __, 40, 80, 70, 45, 60, 55, 89, 43
2 | pivot : 30 | 20, 30, 40, 80, 70, 45, 60, 55, 89, 43

3 | pivot : 80 | 20, 30, 40, 80, 70, 45, 60, 55, 89, 43

4 | pivot : 70 | 20, 30, 40, 80, 70, 45, 60, 55, 89, 43
4 | pivot : 70 | 20, 30, 40, __, 80, 45, 60, 55, 89, 43
4 | pivot : 70 | 20, 30, 40, 70, 80, 45, 60, 55, 89, 43

5 | pivot : 45 | 20, 30, 40, 70, 80, 45, 60, 55, 89, 43
5 | pivot : 45 | 20, 30, 40, __, 70, 80, 60, 55, 89, 43
5 | pivot : 45 | 20, 30, 40, 45, 70, 80, 60, 55, 89, 43

6 | pivot : 60 | 20, 30, 40, 45, 70, 80, 60, 55, 89, 43
6 | pivot : 60 | 20, 30, 40, 45, __, 70, 80, 55, 89, 43
6 | pivot : 60 | 20, 30, 40, 45, 60, 70, 80, 55, 89, 43

7 | pivot : 55 | 20, 30, 40, 45, 60, 70, 80, 55, 89, 43
7 | pivot : 55 | 20, 30, 40, 45, __, 60, 70, 80, 89, 43
7 | pivot : 55 | 20, 30, 40, 45, 55, 60, 70, 80, 89, 43

8 | pivot : 89 | 20, 30, 40, 45, 55, 60, 70, 80, 89, 43

9 | pivot : 43 | 20, 30, 40, 45, 55, 60, 70, 80, 89, 43
9 | pivot : 43 | 20, 30, 40, __, 45, 55, 60, 70, 80, 89
9 | pivot : 43 | 20, 30, 40, 43, 45, 55, 60, 70, 80, 89

```

不变性
>每次遍历，将标记插入后，前outer项都是有序的

>对已经有序/基本有序的数据源，插入排序会快很多，不会进行无谓的操作。

>完全逆序则每次操作都要执行

[代码示例](../../../TutorialCodeSample/src/main/java/com/xcstasy/tutorial/algorithm/sort/InsertionSort.kt)