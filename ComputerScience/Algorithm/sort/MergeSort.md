### 归并排序

典型的分治类算法
>分治算法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。

>分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。

归并排序的时间复杂度为O(N * lgN)。若使用递归实现，递归深度为lgN。

##### 分治法的基本步骤

分治法在每一层递归上都有三个步骤：
* 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；
* 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题
* 合并：将各个子问题的解合并为原问题的解。

##### 它的一般的算法设计模式如下：
Divide-and-Conquer(P)
1. if |P|≤n0
2. then return(ADHOC(P))
3. 将P分解为较小的子问题 P1 ,P2 ,...,Pk
4. for i←1 to k
5. do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi
6. T ← MERGE(y1,y2,...,yk) △ 合并子问题
7. return(T)

>其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,...,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,...,Pk的相应的解y1,y2,...,yk合并为P的解。

##### 简单思路讲解：
```
    二分情况：
    假设有两个有序数组 A:1,3,5,7  | B:2,4,6,8,10
    归并这两个数组为一个有序数组：
    比较A[0]和B[0]，小的就是新数组0号位，也就是A[0]
    比较A[1]和B[0]，小的放在新数组1号位，也就是B[0]
    ...
    完全比较之后，有剩余的数组，剩余元素直接拷贝到新数组最后
```


```
   数据源： 8 , 4 , 9 , 5 , 7 , 1 , 3 , 6 , 2
   分解为N个小问题：9/2 = 4 , 4/2 = 2 , 2/2 = 1
   分解为最小单元  [8]  [4]  [9]  [5] [7]  [1]  [3]  [6]  [2]

   合并 1*2 = 2 并排序
   [4, 8]  [5, 9]  [7, 1]  [3, 6]  [2]
   合并 2*2 = 4 并排序
   [4, 5, 8, 9]  [1, 3, 6, 7]  [2]
   合并 4*2 = 8 并排序
   [1, 3, 4, 5, 6, 7, 9]  [2]
   最后一步归并
   [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

[代码示例](../../../TutorialCodeSample/src/main/java/com/xcstasy/tutorial/algorithm/sort/MergeSort.kt)