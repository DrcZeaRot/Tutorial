### 开放寻址法解决哈希冲突

* 使用开放寻址法插入元素，需要连续地检查散列表，或称之为"探测"，直到找到一个空槽来放置待插入的关键字。
* 探测的顺序不一定是0,1 ... ，m - 1(此时为O(N))，通常要依赖于带插入的关键字。

辅助散列函数：给定一个普通的 散列函数h':U -> {0，1，...，m-1}

##### 线性探测

```
线性探测的散列函数：h(k,i) = (h'(k) + i) mod m ， i = 0，1，...，m-1
```

流程：
1. 给定一个关键字k，首先探测槽T[h'(k)],再探测槽T[h'(k)+1]，以此类推直到T[m - 1]
2. 然后再绕回T[0],T[1]，最后探测到T[h'(k) - 1]

弊端：
* 一次群集
* 随着连续被占用的槽不断增加，平均查找时间也随之不断增加

##### 二次探测(平方探测)
```
二次探测的散列函数：h(k,i) = (h'(k) + c1 * i + c2 * i ^ 2) mod m
```

流程：
1. 初始探测位置T[h'(k)]，后续探测位置添加一个偏移量，该偏移量以二次的方式依赖于探测序号i。

弊端：
* 二次群集
* 两个关键字的初始探测位置相同，则他们的探测序列也相同。

##### 双重散列

```
有两个辅助散列函数
双重散列的散列函数：h(k,i) = (h1(k) + i * h2(k)) mod m
```

流程：
1. 初始探测位置为T[h1(k)]
2. 后续探测位置为：前一个位置加上偏移量h2(k) 再模m

注意：
1. 为了能查找整个散列表 h2(k)必须要与表的大小m 互素。
2. 一种简单的办法：就是取m为2的幂、并设计一个总产生奇数的h2
3. 另一种办法：取m为素数，并设计一个总是返回比m小的正整数的h2

##### 其他方法

![开放寻址法简易公式](../img/OpenAddressingResolver.png)


* 伪随机再散列
    ```
    线性探测的扩展，去取di为一个伪随机数
    ```

* 再哈希/双哈希
    ```
    当p = h(k) 冲突时：以p为基础生成 p1 = h(p)
    当p1 = h(p) 再冲突时， 以p1为基础生成 p2 = h(p1)
    以此类推...
    虽然不易发生聚集，但计算事件增加。
    ```

* 建立公共溢出区域
    ```
    将散列表分为：基本表+溢出表 两部分，与基本表发生冲突的元素，放入溢出表
    ```
