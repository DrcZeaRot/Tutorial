### 堆

堆是符合如下特点的二叉树：
* 它是一棵完全二叉树(除了最后一层意外，其余每一层从左到右都完全是满的)
* 通常使用数组来实现
* 堆中每一个结点都满足堆的条件：
    1. 最大堆：父结点关键字 >= 子结点关键字
    2. 最小堆：父结点关键字 <= 子结点关键字

##### 常用公式

父结点：PARENT(i) = [i/2]

左子结点：LEFT(i) = 2 * i

右子结点：RIGHT(i) = 2 * i + 1

##### 常用操作

最大堆：
* 维持最大堆性质(MaxHeapify)：
    1. 获取当前结点及其左右子结点，获取其中最大结点
    2. 如果当前结点不是最大结点(即后方的节点较大)，则交换这两个结点
    3. 顺着最大结点继续向后递归

* 对任意给定数组进行建堆
    1. 循环：
        1.从最后一个节点的父节点PARENT(last)处(也就是中间元素)开始进行MaxHeapify递归

* 堆排序(O(n*lgn))
    1. 构建最大堆
    2. 循环：从Array.length循环到1号元素
        1. 交换最大元素(Array[0])与最小元素
        2. 将Array中被视为Heap的部分减少1
        3. 对最大结点进行MaxHeapify
    ```
    原理：
        1.最大堆的首尾永远是最大的值
        2.将首尾交换，并进行MaxHeapify之后，末尾为最大值，其余部分依旧是最大堆
        3.减小堆大小并进行循环交换，排序完成
    ```

优先队列(最大堆)相关：

* 获取最大值
    1. Array[0]头位元素即最大堆的最大值

* 获取并去掉最大值
    1. 保证堆大小合法
    2. 获取Array[0]号位最大值
    3. 将Array[last]赋值给Array[0]
    4. 将Array中被视为Heap的部分减少1
    5. 对最大结点进行MaxHeapify
    6. 返回最大值

* 将某个index的值增大到新的值(MaxHeapIncreaseKey)
    1. 新的值如果小于当前值则抛出异常
    2. 将新的值赋值给指定index
    3. 判断当前index与parent的大小，如果parent较小则交换两个值，并将parentIndex赋值给index，继续循环。

* 插入
    1. 将Array中被视为Heap的部分增大1
    2. 为新增的最后一位进行初始赋值
    3. 对最后一位进行MaxHeapIncreaseKey


##### 常见应用

堆排序、优先队列