### 初始化

* 类初始化是类加载过程的最后一步
* 前面的类加载过程中，除了在加载阶段，用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制
* 到了初始化阶段，才真正开始执行类中定义的Java程序代码(或者说是字节码)

##### clinit类初始化

* 在准备阶段，变量已经赋过一次系统要求的初始值
* 在初始化阶段，则根据程序员通过程序制定的主观计划，去初始化类变量和其他资源
* 或者可以从另外一个角度来表达：
    * 初始化阶段是：执行类构造器<_clinit>方法的过程
* <_clinit>()方法执行过程中的一些行为特点和细节：
    1. <_clinit>()方法，是由编译器自动收集类中的所有类变量的赋值动作和静态代码块(static{...})中的语句合并产生的
        * 编译器收集的顺序是由语句在源文件中出现的顺序决定的：
            1. 静态代码块中只能访问到定义在静态代码块之前的变量
            2. 定义在它之后的变量，在前面的静态代码块可以赋值，但是不能访问
    2. <_clinit>()方法与类的构造函数(或者说示例构造器<_init>()方法)不同
        * 他不需要显示地调用父类构造器
        * 虚拟机会保证在子类的<_clinit>()方法执行之前，父类的<_clinit>()方法已经执行完毕
        * 因此：虚拟机中第一个被执行的<_clinit>()方法的类，肯定是java.lang.Object。
    3. 由于父类的<_clinit>()方法先执行
        * 也就意味着：父类中定义的静态代码块要优先于子类的变量赋值操作
    4. <_clinit>()方法对于类或接口来说，并不是必需的
        * 如果一个类中没有静态代码块，也没有对变量的赋值操作
        * 那么编译器可以不为这个类生成<_clinit>()方法
    5. 接口中不能使用静态代码块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<_clinit>()方法。
        * 但接口与类不同的是：执行接口的<_clinit>()方法不需要先执行父接口的<_clinit>()方法
        * 只有当父接口中定义的变量使用时，父接口才会初始化
        * 另外：接口的实现类在初始化时也一样不会执行接口的<_clinit>()方法
    6. 虚拟机会保证一个类的<_clinit>()方法在多线程环境中，被正确地枷锁、同步
        * 如果多个线程同时去初始化一个类
            1. 那么只有一个线程去执行这个类的<_clinit>()方法
            2. 其他线程都需要阻塞等待
            3. 直到活动线程执行<_clinit>()方法完毕
        * 如果在一个类的<_clinit>()方法中，有耗时很长的操作：
            * 可能造成多个进程阻塞
            * 在实际应用中，这种阻塞往往是很隐蔽的
                ```
                需要注意：其他线程虽然会被阻塞
                但如果执行<_clinit>()方法的那个线程退出<_clinit>()方法后
                其他线程唤醒之后，不会再次进入<_clinit>()方法
                同一个类加载器下，一个类型只会初始化一次
                ```