### 加载

```
"加载"是"类加载(Class Loading)"过程的一个阶段，不要混淆
```
在加载阶段，虚拟机需要完成以下3件事：
1. 通过一个类的全限定名来过去定义此类的二进制字节流
    * 并没有指明"二进制字节流"要从一个Class文件中获取
    * 准确的说是：根本没有指明要从哪里获取、怎样获取
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口

##### 开放、自由的加载阶段

```
虚拟机设计团队，在加载阶段搭建了一个相当开放、广阔的舞台，
Java发展历程中，充满创造力的开发人员则在这个"舞台"上玩出了各种花样
```
许多举足轻重的Java技术都建立在这一基础之上：
1. 从zip包中读取：这很常见，最终成为日后jar、ear、war格式的基础
2. 从网络中获取：这种场景最典型的应用就是Applet
3. 运行时计算生成：这种场景使用得最多的就是动态代理技术
    * 在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass来为特定接口生成形势为"*$Proxy"的代理类的二进制字节流
4. 由其他文件生成：典型场景是JSP应用，即由JSP文件生成对应的Class类。
5. 从数据库中读取：这种场景相对少见些。例如：有些中间件服务器(如SAP NetWeaver)可以选择把程序安装到数据库中来完成程序代码在集群间的分发。

##### 数组的加载

一个数组类的创建过程(简称为C)：
1. 如果数组的组件类型(Component Type，指的是：数组去掉一个维度的类型)，是引用类型：
    * 那就递归采用本节中定义的加载过程去加载这个组件类型
    * 数组C将在加载该组件类型的类加载器的类名称空间上被标识(一个类必须与类加载器一起确定唯一性)
2. 如果数组的组件类型，不是引用类型(如：int[]数组)
    * JVM将会把数组C标记为与引导类加载器关联
3. 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public

##### 加载完毕

* 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中
* 方法区中的数据存储格式有VM实现自行定义，VM规范未规定此区域的具体数据结构
* 然后在内存中实例化一个java.lang.Class类的对象(并没有明确规定是在Java堆中，对HotSpotVM而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里)
* 这个对象将作为程序访问方法区中的这些类型数据的外部接口

```
加载阶段与连接阶段的部分内容(如一部分字节码文件格式验证动作)是交叉进行的，
加载阶段尚未完成，连接阶段可能已经开始，
但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容
这两个阶段的开始时间仍然保持着固定的先后顺序
```