### Java虚拟机栈(Java Virtual Machine Stacks)

* JVM栈也是线程私有的(跟程序计数器一样)，它的生命周期与线程相同。
* 虚拟机栈描述的是JAVA方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
* 每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

##### Java的"堆"和"栈"
* 经常有人把Java内存区分为堆内存(Heap)和栈内存(Stack)。这种分发比较粗糙，Java内存区域的划分实际远比这复杂。
* 此方式流行只能说明：大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。
* 其中的"栈"就是虚拟机栈，或者说是：虚拟机栈中局部变量表部分

##### 局部变量表

局部变量表存放了编译器可知的：
* 各种基本数据类型
* 对象引用(reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)
* returnAddress类型(指向了一条字节码指令的地址)

其中：64位长度的long和double类型的数据会占用2个局部变量空间(Slot)，其余的数据类型占用一个。

> 局部变量表所需的内存空间，在编译期间完成分配。当进入一个方法时：这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

##### 操作数栈

* 操作数栈在执行字节码指令过程中被用到，这种方式类似于原生 CPU 寄存器。
* 大部分 JVM 字节码把时间花费在操作数栈的操作上：入栈、出栈、复制、交换、产生消费变量的操作。
* 因此，局部变量数组和操作数栈之间的交换变量指令操作通过字节码频繁执行。

比如：一个简单的变量初始化语句将产生两条跟操作数栈交互的字节码

```
int i;  被编译成下面的字节码：

0:    iconst_0    // Push 0 to top of the operand stack
1:    istore_1    // Pop value from top of operand stack and store as local variable 1
```

##### 动态链接
1. 动态链接概念：
    * 每个栈帧都有一个运行时常量池的引用。这个引用指向栈帧当前运行方法所在类的常量池。通过这个引用支持动态链接（dynamic linking）。
        >C/C++ 代码一般被编译成对象文件，然后多个对象文件被链接到一起产生可执行文件或者 dll。在链接阶段，每个对象文件的符号引用被替换成了最终执行文件的相对偏移内存地址。在 Java中，链接阶段是运行时动态完成的。
    * 在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数
    * 这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析
    * 另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接
    * 动态链接把符号形成的方法调用，翻译成实际的方法调用，装在必要的类、解释还没有定义的符号
    * 并把变量访问编译成 与这些变量运行时的存储结构相应的偏移地址
    * 动态链接方法和变量，使得方法中使用的"其他类的变化"，不会影响到本程序代码

2. 动态链接细节：
    * 当 Java 类文件编译时，所有变量和方法的引用都被当做符号引用存储在这个类的常量池中。
        > 每一个class文件有一个常量池，每一个被Java虚拟机装载的类或者接口都有一份内部版本常量池，被称作运行时常量池
    * 符号引用是一个逻辑引用，实际上并不指向物理内存地址。
    * JVM 可以选择符号引用解析的时机:
        * 一种是当类文件加载并校验通过后，这种解析方式被称为饥饿方式。
        * 另外一种是符号引用在第一次使用的时候被解析，这种解析方式称为惰性方式。
    * 无论如何 ，JVM 必须要在第一次使用符号引用时完成解析并抛出可能发生的解析错误。
    * 绑定是将对象域、方法、类的符号引用替换为直接引用的过程。
    * 绑定只会发生一次。一旦绑定，符号引用会被完全替换。
    * 如果一个类的符号引用还没有被解析，那么就会载入这个类。
    * 每个直接引用都被存储为相对于存储结构（与运行时变量或方法的位置相关联的）偏移量。

##### 方法出口(返回地址)
1. 当一个方法开始执行后，只有两种方式可以退出这个方法：
    * 第一种:执行引擎遇到任意一个方法返回的字节码指令
        1. 这时候可能会有返回值传递给上层的方法调用者
        2. 是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定
        3. 这种退出方法的方式称为正常完成出口
    * 另一种:在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理
        1. 无论是Java虚拟机内部产生的异常，还是代码中使用throw字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出
        2. 这种退出方法的方式称为异常完成出口，一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的
2. 无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行
3. 方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。
4. 一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。
5. 而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息
6. 方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：
    * 恢复上层方法的局部变量表和操作数栈
    * 把返回值（如果有的话）压入调用者栈帧的操作数栈中
    * 调整PC计数器的值以指向方法调用指令后面的一条指令等

##### 其他、异常
JVM规范中，对这个区域规定了两种异常状况：
* 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常
* 如果虚拟机栈可以动态扩展(当前大部分的JVM都可动态扩展，只不过JVM规范中也允许固定长度的虚拟机栈)，在扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

#### 参考
[JVM内幕：Java虚拟机详解](http://www.importnew.com/17770.html)