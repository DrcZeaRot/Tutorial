### 对象内存布局

HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：
1. 对象头(Object Header)
2. 实例数据(Instance Data)
3. 对齐填充(Padding)

##### 对象头

对象头包括两部分信息：
1. 一部分用于存储对象自身的运行时数据：
    * 如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等
    * 这部分数据的长度在32位和64位虚拟机(未开启压缩指针)中分别为32bit和64bit，官方称其"Mark Word"
    * 对象需要存储的运行时数据很多，已经超出了32位、64位Bitmap结构所能记录的限度
        * 但对象头信息是与对象自身定义的数据无关的额外存储成本
        * 考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在技校的空间内存储尽量多的信息
        * 它会根据对象的状态，复用自己的存储空间。
    * 例如，32位的HotSpot虚拟机中：
        * 如果对象处于未被锁定的状态下
        * Mark Word的32bit空间中：25bit存储哈希码、4bit存储分代年龄、2bit存储锁标志位、1bit固定为0
        * 其他状态(轻量级锁定、重量级锁定、GC标记、可偏向)下，对象的存储也有不同，此处不展开
2. 另一部分是类型指针：
    * 即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例
    * 并不是所有的虚拟机实现都必须在对象时局上保留类型指针。
    * 换句话说：查找对象的元数据信息，并不一定要经过对象本身。
    * 另外：如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据：
        1. 因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小
        2. 但是，从数组的元数据中却无法确定数组的大小

##### 实例数据

* 实例数据部分，是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容
* 无论是从父类继承下来的、还是在子类中定义的，都需要记录起来
* 这部分的存储顺序会受到虚拟机分配策略参数(FieldsAllocationStyle)和字段在Java源码中定义顺序的影响
    * HotSpot虚拟机默认的分配策略为：longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers)
    * 从分配策略中可以看出：相同宽度的字段，总是被分配到一起。
* 在满足这个前提条件的情况下，父类中定义的变量，会出现在子类之前
* 如果CompactFields参数值为true(默认为true)，那么子类中较窄的变量，也可能会插入到父类变量的空隙中。

##### 对齐填充

* 对齐填充，并不是必然存在的，也没有特别的含义。它仅仅起占位符的作用。
* 由于：HotSpot虚拟机的自动内存管理系统，要求对象起始地址必须是8字节的整数倍
* 换句话说：对象的大小必须是8字节的整数倍。
* 对象头部分正好是8字节的倍数，因此，当对象实力数据部分没有对齐时，需要对齐填充来补全。

