### 对象的创建

> 此处只涉及普通Java对象，数组和Class对象不在讨论范围

##### 类加载

虚拟机在遇到一条new指令时：
* 首先去检查这个指令的参数<是否能在常量池中定位到一个类的符号引用>
* 并检查这个符号引用代表的类，是否已被加载、解析和初始化过。
* 如果没有，那必须先执行相应的[类加载过程](../../ClassLoader/ClassLoader.md)

##### 内存分配

* 类加载检查通过之后，接下来虚拟机将为新生对象分配内存。
* 对象所需内存的大小，在类加载完成后便可[完全确定](ObjectMemoryLayout.md)。
* 为对象分配空间的任务，等同于：把一块确定大小的内存从Java堆中划分出来。

分配内存的方式：(选择哪种由Java堆是否规整决定，而是否规整由垃圾收集器是否带有压缩整理功能决定)
1. 指针碰撞(Bump the Pointer)：
    * 假设Java堆中内存时绝对规整的
    * 所有用过的内存都放在一边，空闲的内存放在另一边
    * 中间放着一个指针作为分界点的指示器
    * 所分配内存就仅仅是把那个指针向空闲那边挪动一段与对象大小相等的距离
2. 空闲列表(Free List)：
    * 如果Java堆中的内存并不是规整的，已使用和空闲的内存相互交错
    * 此时没法简单地进行指针碰撞，虚拟机必须维护一个列表，记录哪些内存块是可用的
    * 在分配的时候，从列表中找到一块足够大的空间，划分给对象实例，并更新列表上的记录

##### 初始化

* 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为"零值"(不包括对象头)。(此操作保证对象的实例字段，在Java代码中可以不赋初始值就 可以直接使用)
* 接下来，虚拟机要对对象进行必要的设置。例如：
    1. 这个对象是哪个类的实例
    2. 如何才能找到类的元数据信息
    3. 对象的哈希码
    4. 对象的GC分代年龄等信息
    5. 这些信息存放在对象的对象头(Object Head)中。

##### init方法

* 上述工作都完成之后，在虚拟机的视角来看，一个新的对象已经产生了
* 但从Java程序的角度来看，对象创建才刚刚开始——<_init>方法还没有执行，所有的字段还都为零
* 所以，一般来说，执行new指令之后会接着执行<_init>方法，把对象按照程序员的意愿进行初始化
* 这样一个真正可用的对象才算完全产生出来