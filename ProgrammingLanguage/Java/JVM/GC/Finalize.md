### 生存还是死亡

> 即使在可达性分析算法中不可达的对象，也并非是"非死不可"的，这时候它们暂时处于"缓刑"阶段

要真正宣告一个对象死亡，至少要经理两次标记过程：
1. 第一次标记：
    * 如果对象在进行可达性分析后，发现没有雨GC Roots相连的引用链
    * 那它将会被[第一次标记]()，并且进行一次筛选。
    * 筛选的条件是：此对象是否有必要执行finalize()方法
    * "没必要执行"的情况是：当对象没有覆盖finalize()方法、或finalize()方法已被VM调用过
    * 注意：任何一个对象的finalize()方法只会被系统自动调用一次。第二次面临回收时，finalize()方法不会被再次执行。
2. 第二次标记：
    * 如果这个对象呗判定为有必要执行finalize()方法：
        * 那这个对象会被放置在一个叫做F-Queue的队列中
        * 并在稍后由一个VM自动建立的、低优先级的Finalizer线程去执行它
        ```
        这里所谓的"执行"是指：虚拟机会触发这个方法，但并不承诺会等待它运行结束
        这么做的原因是：
        如果一个对象在finalize()方法中执行缓慢，或者发生了死循环
        将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃
        ```
    * finalize()方法是对象逃脱死亡命运的最后一次机会
        * 稍后GC将对F-Queue中的对象进行[第二次小规模的标记]()
        * 如果对象要在finalize()中成功拯救自己：
            1. 只要重新与引用链上的任何一个对象建立关联即可
            2. 譬如把自己(this关键字)赋值给某个类变量、或者对象的成员变量
            3. 那在第二次标记时，它将被移出"即将回收"的集合
        * 如果对象这时候还没有逃脱，那基本上它就真的被回收了

##### finalize()的注意事项

应该尽量避免使用finalize()方法：
* 它不是C/C++中的析构函数，只是Java刚诞生时为了让C/C++程序员更容易接受Java，而做出的一个妥协
* 它的运行代价高昂、不确定性大，无法保证各个对象的调用顺序
* 某些教材中描述它"适合做关闭外部资源之类的工作"，也完全是对这个方法用途的一种自我安慰
* finalize()能做的所有工作，使用try-finally或者其他方式，都可以做得更好、更及时
* 建议可以完全忘掉Java语言中有这个方法的存在