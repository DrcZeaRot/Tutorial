### 内存分配与回收策略

分配梗概：
* 对象的内存分配，往大方向讲，就是在堆上分配
* 对象主要分配在新生代的Eden区上(如果启动了本地线程分配缓冲，将按线程有限，在TLAB上分配)
* 少数情况下也可能会直接分配在老年代中
* 分配规则不是100%固定的，细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数设置。

* JVM中堆内存的划分：
    1. 新生代(Young Generation)
    2. 老年代(Tenured Generation)
    3. 持久/永久代(Permanent Generation):<在JDK8里已经把永久代删除了>
* 新生代和老年代的划分，对垃圾回收影响比较大


##### 基础分配机制

基础分配机制：
1. 新对象被分配到新生代的Eden区
2. 大对象可以被直接分配到老年代
    * 大对象指：需要大量连续内存空间的Java对象。最典型的就是很长的字符串、以及数组。
    * 使用-XX:PretenureSizeThreshold参数设定
3. 长期存活的对象进入老年代

##### 分配、回收过程：
1. 大多数情况下，对象在新生代Eden去中分配。(目的就是快速回收掉寿命较短的对象)
    > 新生代分为：一个Eden区(名叫eden)和2个Survivor区(名叫from和to)，默认比例为8:1:1(设置-XX:SurvivorRatio = 8，更改比例)
2. 当Eden区被填满时，虚拟机发起一次Minor GC
    1. 尝试把存活对象放入Survivor的from区(如果也放不下，通过分配担保，提前转移到老年代)，并将对象年龄设为1
    2. 清空Eden区
3. 当Eden区再次被填满时，对Eden区和from区同时进行Minor GC
    1. 尝试把存活对象放入Survivor的to区
    2. 清空Eden区和from区
4. 步骤2和步骤3会一直重复
5. 虚拟机给每个对象定义了一个对象年龄计数器
    1. 对象在Survivor区每"熬过"一次Minor GC，年龄就增加一岁
    2. 当它的年龄增加到一定程度(默认为15，-XX:MaxTenuringThreshold)，就会被晋升到老年代
6. 老年代被填满，触发Major GC

分代GC的区别：
1. 新生代GC(Minor GC)：
    * 发生在新生代的垃圾收集动作
    * 大部分Java对象是朝生夕灭的，所以Minor GC很频繁，回收速度也较快
2. 老年代GC(Major GC/Full GC)：
    * 发生在老年代的GC
    * 出现Major GC，通常会伴随至少一次的Minor GC(也并非绝对)
    * Major GC的速度一般会比Minor GC慢10倍以上

##### 动态对象年龄判定

VM并不是永远要求对象年龄必须到达MaxTenuringThreshold才能金收入能够老年代：
* 如果在Survivor空间中，相同年龄多有对象大小的综合，大于Survivor空间的一半
* 年龄大于或等于该年龄的对象就可以直接进入老年代

##### 空间分配担保

发生Minor GC之前，VM会先检查老年代最大可用的连续空间，是否大于新生代所有对象总空间
* 如果条件成立：则此次Minor GC可以确保是安全的
* 如果条件不成立：
    1. VM先查看HandlePromotionFailure值是否允许担保失败(为避免Full GC过于频繁，通常允许失败)
        1. 如果允许：继续检查老年代最大可用连续空间是否大于<历次晋升到老年代对象的平均大小>
        2. 如果大于，将尝试进行一次Minor GC(即使可能发生担保失败)
        3. 担保失败如果发生，则会重新发起一次Full GC
    2. 如果小于、或者不允许冒险，此次GC将改为进行一次Full GC