### 方法分派

分派分类：
1. 分派调用：可能是静态的，也可能是动态的
2. 依据<宗量数>可分为：单分派、多分派
3. 两两组合，构成了4种情况：
    1. 静态单分派
    2. 静态多分派
    3. 动态单分派
    4. 动态多分派

##### 分派与多态

* Java具备面向对象的3个基本特征(继承、封装、多态)
* 分派调用的过程，会解释"多态性"特征的 一些最基本的体现
    1. 如："重载"和"重写"在Java虚拟机中时如何实现的
    2. 主要关心的是：虚拟机如何确定正确的目标方法

##### 静态分派


[Overload——静态类型Vs实际类型](../../../../TutorialCodeSample/src/main/java/com/xcstasy/tutorial/jvm/methodcall/StaticDispatch_OverLoadStaticVsActual.java)
通过如下代码，定义两个概念：
```
Human man = new Man()
```
1. 代码中的"Human"称为：变量的静态类型(Static Type)，或者叫外观类型(Apparent Type)
2. new关键字之后的"Man"则称为：变量的实际类型(Actual Type)
3. 静态类型和时机类型，在程序中都可以发生一些变化，区别是：
    1. 静态类型的变化，仅仅是在使用时发生
        * 变量本身的静态类型不会被改变。
        * 并且，最终的静态类型是在编译期可知的
    2. 而实际类型变化的结果，在运行期才可以确定
        * 编译期在编译程序的时候，并不知道一个对象的实际类型是什么

通过如下代码，尝试解释这两种类型：
```
//实际类型变化：
Human man = new Man();
man = new Woman();
//静态类型变化：
dispatch.sayHello((Man)man);
dispatch.sayHello((Woman)man);
```
1. 示例代码中，定义了2个静态类型相同，但实际类型不同的变量
2. 但VM(准确的说是编译器)在重载(Overload)时，是通过参数的静态类型，而不是实际类型作为判定依据的
3. 静态类型是编译器可知的：
    * 因此，在编译阶段，Javac编译器会根据参数的静态类型，决定使用哪个重载版本

静态分派：
* 所有依赖静态类型，来定位方法执行版本的分派动作，称为静态分派
* 静态分派的典型应用是方法重载
* 静态分派发生在编译阶段，因此，确定静态分派的动作，实际上不是由虚拟机来执行的
* 另外：
    1. 编译器虽然能确定出方法的重载版本
    2. 但很多情况下，这个重载版本，并不是"唯一的"
    3. 往往只能确定一个"更加适合"的版本
* 如下示例(解释在代码中)：

[Overload复杂示例](../../../../TutorialCodeSample/src/main/java/com/xcstasy/tutorial/jvm/methodcall/StaticDispatch_OverLoadMoreSpecific.java)

注意：
* 解析与分派，这两者之间的关系，并不是二选一的排他关系
* 他们是在不同层次上去筛选、确定目标方法的过程
* 如：静态方法会在类加载期进行解析，但静态方法也可以重载，重载版本的选择过程也是通过静态分派完成的。

##### 动态分派

[Override示例](../../../../TutorialCodeSample/src/main/java/com/xcstasy/tutorial/jvm/methodcall/DynamicDispatch_Override.java)
> 动态分派与重写(Override)有比较密切的关联，讲解在示例代码中。

Java虚拟机是如何根据实际类型，来分派方法执行版本的呢？
```
字节码讲解参见《深入理解Java虚拟机》8.3.2节-动态分派
```
* 原因从invokevirual指令的多态查找过程开始说，该指令的运行时解析过程大致分为：
    1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。
    2. 如果，在类型C中找到与常量中描述符合简单名称都相符的方法：
        * 则进行访问权限校验，如果通过：则返回这个方法的直接引用，查找结束
        * 如果不通过，则返回java.lang.IllegalAccessError异常
    3. 否则，按照继承关系，从下往上，一次对C的各个父类进行Step2的搜索和验证过程
    4. 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常
* 由于invokevirual指令执行的第一步，就是在运行期确定接受者的实际类型
    * 所以，示例代码的两次调用中的invokevirtual指令
    * 把常量池中的类方法符号引用，解析到了不同的直接引用上
* 这个过程，就是Java语言中重写的本质

```
我们把这种，在运行期根据实际类型，确定方法执行版本的分派过程，称为：动态分派
```

##### 单分派Vs多分派

```
方法的接受者，与方法的参数，统称为方法的"宗量"
这个定义，最早应该来源于《Java与模式》一书
```
根据分派基于多少宗量，可将分派划分为2种：
1. 单分派：根据一个宗量，对目标方法进行选择
2. 多分派：根据多于1个宗量，对目标方法进行选择

[单分派、多分派示例代码](../../../../TutorialCodeSample/src/main/java/com/xcstasy/tutorial/jvm/methodcall/Dispatch_SingleVsMulti.java)

总结来说：
```
目前的(直至JDK1.8)的java语言，是一门：静态多分派、动态单分派的语言
```
