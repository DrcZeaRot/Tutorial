### 方法调用——方法解析

方法调用，并不等同于方法执行：
* 方法调用阶段唯一的任务就是
    * 确定被调用方法的版本(即调用哪一个方法)
    * 暂时还不涉及方法内部的具体运行过程。
* 程序运行时，进行方法调用，是最普遍、最频繁的操作。
* 前文提到：
    1. CLass文件的编译过程中，不包含传统编译中的连接步骤
    2. 一切方法调用，在Class文件里存储的都只是符号引用(而不是方法在实际运行时内存布局中的入口地址<相当于之前说的直接引用>)
* 这个特性，给Java带来了更强大的动态扩展能力
    * 但也使得Java方法调用过程变得相对复杂起来：
        1. 需要在类加载期间
        2. 甚至到运行期间才能确定目标方法的直接引用

##### 什么是解析

继续前面方法调用的话题：
1. 所有方法调用中的目标方法，在Class文件里都是一个常量池中的符号引用
2. 在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用
3. 这种解析能成立的前提是：
    1. 方法在程序真正运行之前，就有一个可确定的调用版本
    2. 并且这个方法的调用版本，在运行期是不改变的
4. 换句话说：调用目标再程序代码写好、编译器进行编译时，就必须确定下来
5. 这类方法的调用，称为："解析"

##### 通过解析可以确定的方法

```
Java语言中，符合"编译期可知，运行期不可变"这个要求的方法
主要包括<静态方法>和<私有方法>两大类。
前者与类型直接关联、后者在外部不可被访问
这两种方法各自的特点决定了：他们都不可能通过继承或别的方式重写其他版本
因此，他们都适合在类加载阶段进行解析
```

与之相对的是：Java虚拟机里面提供了5条方法调用字节码指令：
1. invokestatic：调用静态方法
2. invokespecial：调用实例构造器<_init>方法、私有方法、父类方法
3. invokevirtual：调用所有的虚方法(与"非虚方法"相对)
4. invokeinterface：调用接口方法，会在运行时在确定一个实现此接口的对象
5. invokedynamic：
    * 先在运行时动态解析出调用电限定符所引用的方法，然后在执行该方法
    * 在此之前的4条调用指令，分派逻辑是固话在Java虚拟机内部的
    * 而invokedynamic指令的分派逻辑，是由用户所设定的引导方法决定的

##### 虚方法、非虚方法

只要能被invokestatic和invokespecial指令调用的方法：
* 都可以在解析阶段中，确定唯一的调用版本
* 符合这个条件的有4种：
    1. 静态方法
    2. 私有方法
    3. 实例构造器
    4. 父类方法
* 它们在类加载的时候，就会把符号引用解析为该方法的直接引用
* 这些方法可以称为"非虚方法"
* 与此相反，其他方法称为"虚方法"(除了final方法)

非虚方法中，除了使用invokestatic、invokespecial调用的方法外，还有一种：
* 就是被final修饰的方法
* 虽然final方法是用invokevirtual指令调用的
* 但由于它无法被覆盖，没有其他版本
* 所以也无需对方法接受者进行多态选择
* 又或者说，多态选择的结果肯定是唯一的
* Java语言规范中，明确说明了：final方法是一种非虚方法

##### 总结

* 解析调用一定是个静态的过程，在编译期间就完全确定
* 在类装载的解析阶段：
    1. 就会把设计的符号引用全部转变为可确定的直接引用
    2. 不会延迟懂啊运行期再去完成