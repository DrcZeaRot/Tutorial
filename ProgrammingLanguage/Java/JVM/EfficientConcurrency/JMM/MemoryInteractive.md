### 内存间的交互操作

```
关于主内存与工作内存之间具体的交互协议，
即：<一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之内>的实现细节，
Java内存模型中，定义了8中操作来完成。
```

##### 8种内存操作

虚拟机实现时，必须保证如下8种操作都是原子的、不可再分的([long和double可能有例外](Long&Double.md))：
```
基于理解难度和严谨性考虑，最新的JSR-133文档中，
已经放弃采用这8种操作去定义Java内存模型的访问协议了。
但仅仅是描述方式改变了，Java内存模型并没有改变
```

1. lock(锁定)：作用于主内存的变量
    * 它把一个变量标识为<一条线程独占>的状态
2. unlock(解锁)：作用于主内存的变量
    * 它把一个处于锁定状态的变量释放出来
    * 释放后的变量才可以被其他线程锁定
3. read(读取)：作用于主内存的变量
    * 它把一个变量的值，从主内存传输到线程的工作内存中
    * 以便随后的load动作使用
4. load(载入)：作用于工作内存的变量
    * 它把read操作从主内存中得到的变量值，放入工作内存的变量副本中
5. use(使用)：作用于工作内存的变量
    * 它把工作内存中的一个变量的值，传递给执行引擎
    * 每当虚拟机遇到一个需要使用到变量值的字节码指令时，将会执行这个操作
6. assign(赋值)：作用于工作内存的变量
    * 它把一个从执行引擎接收到的值，赋给工作内存的变量
    * 每当虚拟机遇到一个给变量赋值的字节码指令时，执行这个操作
7. store(存储)：作用于工作内存的变量
    * 它把工作内存中一个变量的值，传送到主内存中
    * 以便随后的write操作使用
8. write(写入)：作用于主内存的变量
    * 它把store操作从工作内存中的到的变量的值，放入主内存的变量中


```
如果要拔一个变量，从主内存复制到工作内存：就要顺序地执行read和load操作；
如果要拔变量从工作内存同步回主内存：就要顺序地执行store和write操作；
注意：Java内存模型，只要求上述两个操作必须<按顺序执行>，而没有要求<保证连续执行>。
也就是说：read和load之间、store和write之间，是可插入其他指令的。

如，对主内存中的变量a、b进行访问时：
一种可能出现的顺序是：read a、read b、load b、load a。
```

##### 执行规则

1. 不允许read和load、store和write操作之一单独出现
    * 即：不允许一个变量从主内存读取了，但工作内存不接受
    * 或：从工作内存发起回写了，但主内存不接受的情况出现
2. 不允许一个线程丢弃它的最近assign操作
    * 即：变量在工作内存中改变了之后，必须把该变化同步回主内存
3. 不允许一个线程无原因地(没有发生过任何assign操作)把数据从线程的工作内存，同步回主内存
4. 一个新的变量，只能在主内存中"诞生"
    * 不允许在工作内存中直接使用一个未被初始化(load或assign)的变量
    * 换句话说就是：对一个变量实施use、store操作之前，必须先执行过了assign和load曹组
5. 一个变量在同一个时刻，只允许一条线程对其进行lock操作
    * 但lock操作可以被同一条线程重复执行多次
    * 多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁
6. 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值
    * 在执行引擎使用这个变量之前，需要重新进行load或assign操作初始化变量的值
7. 如果一个变量，事先没有lock操作锁定
    * 那就不允许对它执行unlock操作
    * 也不允许去unlock一个被其他线程锁定住的变量
8. 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行store、write操作)

##### 小结

> 8种内存访问操作以及上述规则限定(再加上对[volatile](Volatile.md)的一些特殊规定)，就已经完全确定了Java程序中哪些内存访问操作在并发下是安全的。

* 由于这种定义相当严谨但又十分繁琐，实践起来很麻烦
* [先行发生原则](HanppensBefore.md)，作为与上述定义的等效判断原则，可以用于确定<一个访问在并发环境下是否安全>。