### 先行发生原则(Happens-Before)

```
如果Java内存模型中，所有的有序性，都仅仅依靠volatile和synchronized来完成，那么有一些操作会变得很繁琐。
但是我们在编写Java并发代码的时候，并没有感觉到这一点。
这是因为：Java语言中有一个<先行发生>的原则。
```
* 这个原则非常重要，它是判断数据<是否存在竞争>、<线程是否安全>的主要依据
* 依靠这个原则，我们可以通过几条规则，一揽子解决并发环境下，两个操作之间是否可能存在冲突的所有问题。

##### 定义

<先行发生>是Java内存模型中定义的，两项操作之间的偏序关系
* 如果说操作A先行发生于操作B
* 其实就是说：在发生操作B之前，操作A产生的影响，能被操作B观察到
* "影响"包括：修改了内存中共享变量的值、发送了消息、调用了方法等。

##### "天然的"先行发生关系

```
这些先行发生关系，无须任何同步器协助，就已经存在，可以在编码中直接使用。
如果两个操作之间的关系不在此列，并且无法从下列规则中推倒出来的话，
他们就没有顺序性保障，虚拟机可以对他们随意地进行重排。
```

1. 程序次序规则(Program Order Rule)：
    * 在一个线程内，按照程序代码顺序，书写在前面的操作，先行发生于书写在后面的操作。
    * 准确地说：应该是控制流顺序，而不是代码顺序。因为：要考虑分支、循环等结构。
2. 管程锁定规则(Monitor Lock Rule)：
    * 一个unlock操作先行发生于后面对同一个锁的lock操作
    * 这里必须强调的是：同一个锁。而"后面"是指时间上的先后顺序。
3. volatile变量规则(Volatile Variable Rule)：
    * 对一个volatile变量的写操作，先行发生于，后面对这个变量的读操作。
    * "后面"同样是指时间上的先后顺序
4. 线程启动规则(Thread Start Rule)：
    * Thread对象的start()方法，先行发生于此线程的每一个动作。
5. 线程终止规则(Thread Termination Rule)：
    * 线程中的所有操作，都先行发生于，对此线程的终止检测
    * 我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段，检测到线程已经终止执行。
6. 线程中断规则(Thread Interruption Rule)：
    * 对线程interrupt()方法的调用，先行发生于，被中断线程的代码检测到中断事件的发生
    * 可以通过Thread.interrupted()方法检测到是否有中断发生
7. 对象终结规则(Finalizer Rule)：
    * 一个对象的初始化完成(构造函数执行结束)，先行发生与，它的finalize()方法的开始
8. 传递性(Transitivity)：
    * 如果操作A先行发生于操作B、操作B先行发生于操作C
    * 就可以得出结论：操作A先行发生于操作C
##### 一切以先行发生原则为准
```
在多线程中，一个操作"时间上的先发生"，不代表这个操作会是"先行发生"。
反过来，一个操作"先行发生"，也无法推倒出这个操作必定是"时间上的先发生"。(单线程中也会存在指令重排)
```

* 时间先后顺序，与先行发生原则之间，基本没有太大的关系。
* 所以，衡量并发安全问题的时候，不要受到时间顺序的干扰。