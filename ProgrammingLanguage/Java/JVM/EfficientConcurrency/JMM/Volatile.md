### Volatile型变量的特殊规则

关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制。
> 但它并不容易完全被正确、完整地理解。导致很多Coder习惯不去使用它，遇到需要处理多线程数据竞争问题时候一律使用synchronized来进行同步。

##### 通俗语义解释

当一个变量定义为volatile之后，它将具备两种特征：
1. 第一：保证此变量对所有线程的可见性
    ```
    这里的"可见性"是指：当一条线程修改了这个变量的值，
    新值对于其他线程来说，是可以立即得知的
    ```
    * 普通变量不能做到这一点
        * 普通变量的值在线程之间传递，均需要通过主内存来完成
        * 例如：
        ```
        线程A修改一个普通变量的值，然后向主内存进行回写，
        另外一条线程B在线程A回写完成了之后，在从主内存进行读取操作，
        新变量值才会对线程B可见
        ```
    * 关于volatile变量的可见性，经常被开发人员误解：
        1. 认为以下描述成立：
            ```
            "volatile变量，对所有线程是立即可见的，对volatile变量所有的写操作都能够立即反应到其他线程之中"
            换句话说："volatile变量在各个线程中是一致的，所以基于volatile变量的运算，在并发下是安全的"
            ```
        2. 上面一句话的论据部分并没有错，但此论据不能得出"volatile并发安全"这个结论
    * volatile变量在各个线程的工作内存中，不存在一致性问题
        ```
        各个线程的工作内存中，volatile变量也可以存在不一致的情况，
        但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题。
        ```
    * 但Java里的运算并非原子操作
        * 导致volatile变量的运算在并发下一样是不安全的
    * 示例见《深入理解Java虚拟机》12.3.3节
    * 由于volatile变量只能保证可见性，在不符合一下两条规则的运算场景中，我们仍要通过加锁来保证原子性
        1. 运算结果并不依赖变量的当前值，或能够确保只有单一的线程修改变量的值
        2. 变量不需要与其他的状态变量共同参与不变约束
2. 第二：禁止指令重排优化
    * 普通的变量仅仅会保证：
        1. 在该方法执行过程中，所有依赖赋值结果的地方都能获取到正确的结果
        2. 但不能保证变量赋值操作的顺序与程序代码中的执行顺序一致
    * 因为：在一个线程的方法执行过程中无法感知到这点
        * 这也就是Java内存模型中描述的所谓的"线程内表现为串行的语句"(Within-Thread As-If-Serial Semantics)
    * 示例见《深入理解Java虚拟机》12.3.3节

众多并发安全工具中，选用volatile的意义：
1. 某些情况下，volatile的同步机制性能确实要优于锁，但很难量化地认为volatile会比synchronized快多少
2. 如果让volatile和自己比较，可以确定的原则是：
    1. volatile读操作的性能消耗与普通变量几乎没有差别
    2. 但写操作则可能会慢一些。因为：它需要在本地代码中插入许多内存屏障指令，来保证处理器不发生乱序执行
3. 不过即便如此，大多数场景下，volatile的总开销仍然要比锁低
4. 在volatile与锁之中选择的唯一依据，仅仅是：volatile的语义，能否满足使用场景的需求

##### 具体访问规则
> 假定：T表示一个线程，V和W分别表示两个volatile变量，那么在进行read、load、use、assign、store和write操作室，需要满足：

1. 只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作
    * 并且：只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作
    * 线程T对变量V的use动作，可以认为是和线程T对变量V的load、read动作相关联，必须连续一起出现
        ```
        这条规则要求：在工作内存中，每次使用V前都必须先从主内存刷新最新的值，
        用于保证能看见其他线程对变量V所做的修改后的值
        ```
2. 只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store操作
    * 并且：只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign动作
    * 线程T对变量V的assign动作可以认为是和线程T对变量V的store、write动作相关联，必须连续一起出现
        ```
        这条规则要求：在工作内存中，每次修改V后，都必须立刻同步回主内存中，
        用与保证其他线程可以看到自己对变量V所做的修改
        ```
3. 假定：
    1. 动作A是线程T对变量V实施的use或assign动作
        * 动作F是和动作A相关联的load或store动作
        * 动作P是和动作F相关联的read或write动作
    2. 动作B是线程T对变量W实施的use或assign动作
        * 动作G是和动作B相关联的load或store动作
        * 动作Q是和动作G相关联的read或write动作
    3. 如果A先于B，那么P先于Q
        ```
        此规则要求：volatile修饰的变量不会被指令重排优化，
        保证代码的执行顺序与程序的顺序相同
        ```

