### 线程安全的实现方法

你需要什么来实现线程安全：
* 如何实现线程安全，与代码编写有很大的关系
* 但虚拟机提供的同步和锁机制也起到非常重要作用。

##### 互斥同步(MutualExclusion&Synchronization)

互斥同步是常见的一种并发正确性保障手段：
* 同步指的是：
    * 多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个(或者是一些，使用信号量的时候)线程使用。
* 互斥是实现同步的一种手段：
    * 临界区(Critical Section)、互斥量(Mutex)和信号量(Semaphore)都是主要的互斥实现方式
* 这4个字里：互斥是因，同步是果；互斥是方法，同步是目的。

Java中的互斥同步：
1. 最基本的互斥同步手段就是，synchronized关键字
    * synchronized关键字经过编译之后：
        1. 会在同步块的前后分别形成monitorenter和monitorexit两个字节码指令
        2. 这两个指令都需要一个reference类型的参数，来指明要锁定和解锁的对象
        3. 如果代码中synchronized明确指定了对象参数(如：synchronized(mLock){...})，那就是这个对象的reference
        4. 如果没有明确指定，就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为所对象
    * 根据虚拟机规范要求：
        1. 执行monitorenter指令时：
            * 受限要尝试获取对象的锁
            * 如果这个对象没有被锁定、或者当前线程已经拥有了那个独享的锁
            * 把锁的计数器+1，
        2. 执行monitorexit指令时：
            * 将锁的计数器-1
            * 当计数器为0时，锁就被释放
        3. 如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。
    * 虚拟机规范对monitorenter和monitorexit的行为描述，有2点要特别注意：
        1. synchronized同步块对同一条线程来说，是可重入的，不会出现自己把自己死锁的情况。
        2. 同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。
2. 还可以使用java.util.concurrent包中的重入锁(ReentrantLock)来实现同步：
    * 基本用法上，ReentrantLock和synchronized很相似
        * 他们都具备一样的线程重入特性，只是代码写法上有点区别
        * 重入锁：表现为API层面的互斥锁(lock()和unlock()方法，配合try/finally语句块完成)
        * synchronized：表现为原生语法层面的互斥锁
    * ReentrantLock增加了一些高级功能：
        1. 等待可中断
            * 当持有锁的线程长期不释放锁的时候
            * 正在等待的线程可以选择放弃等待，改为处理其他事情
            * 可中断特性对处理执行时间非常长的同步块很有帮助
        2. 公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来一次获得锁
            * 非公平锁不能保证这一点，锁被释放时，任何一个等待锁的线程，都有机会获得锁
            * synchronized中的锁是非公平的
            * ReentrantLock可以构造为公平/非公平的。
        3. 锁可以绑定多个条件
            * ReentrantLock对象可以同时绑定多个Condition对象
            * synchronized中
                1. 锁对象的wait()和notify()或notifyAll()方法，可以实现一个隐含的条件
                2. 但如果要和多于一个条件关联的时候，就不得不额外地添加一个锁
            * ReentrantLock只需要多次调用newCondition()方法即可。
3. 两者的性能对比，采用吞吐量对比实验：
     * JDK1.5时，synchronized的吞吐量下降得严重，而ReentrantLock则基本保持在稳定水平。
     * 与其说ReentrantLock性能更好，不如说"synchronized还有非常大的优化余地"
     * JDK1.6中，加入了很多针对锁的优化措施。之后，两者的性能基本完全持平了。

##### 非阻塞同步(Non-Blocking Synchronization)

> 互斥同步最主要的问题就是进行线程阻塞/唤醒带来的性能问题。因此这种同步也称为"阻塞同步"

处理问题的乐观与悲观：
1. 悲观：
    * 互斥同步属于一种悲观的并发策略
    * 总是认为：只要不去做正确的同步措施(例如加锁)，就肯定会出现问题
    * 无论通向数据是否真的会出现竞争，它都要进行：
        1. 加锁(此处讨论的是改变模型，虚拟机实际上会优化掉很大一部分不必要的锁)
        2. 用户态核心态转换
        3. 维护锁计数器
        4. 检查是否有被阻塞的线程需要唤醒 等操作。
2. 乐观：
    * 随着硬件指令集的发展，有了另外一种选择：基于冲突检测的乐观并发策略
    * 通俗地说就是：
        1. 先进行操作
        2. 如果没有其他线程争用共享数据，那操作就成功了
        3. 如果共享数据有争用，产生了冲突，那就再采取其他的补救措施(最常见的补救措施就是不断重试，直到成功)
    * 这种乐观的并发策略的许多实现，都不需要把线程挂起
    * 因此这种同步操作称为：非阻塞同步

为何乐观并发策略需要"硬件指令集的发展"？
1. 因为我们需要操作和冲突检测这两个步骤，具备原子性，但怎么保证呢？
    * 如果这里再使用互斥同步来保证，就失去意义了
    * 所以我们只能靠硬件来完成这件事
2. 硬件保证一个<语义上看起来需要多次操作>的行为，只通过一条处理器指令就能完成
    * 常用指令有：
        1. 测试并设置(Test-and-Set)
        2. 获取并增加(Fetch-and-Increment)
        3. 交换(Swap)
        4. 比较并交换(Compare-and-Swap，CAS)
        5. 加载链接/条件存储(Load-Linked/Store-Conditional，LL/SC)
    * 其中，前面3条是20实际就已经存在于大多数指令集之中的处理器指令
    * 后面的2条是现代处理器新增的，并且着2条指令的目的和功能是类似的。

CAS指令简析：
1. 需要有3个操作数，分别是：
    1. 内存位置(Java中可以简单理解为变量的内存地址，用V表示)
    2. 旧的预期值(用A表示)
    3. 新值(用B表示)
2. Cas指令执行时：
    1. 当且仅当V复核旧预期值A时，处理器用新值B更新V的值，否则就不执行更新
    2. 但无论是否更新了V的值，都会返回V的旧值。
    3. 上述的处理过程，是一个原子操作
CAS指令：
1. 漏洞
    1. 如果一个变量V初次读取的时候是A值
    2. 并且在准备赋值的时候，见到到它仍然为A值
    3. 我们就能说它的值没有被其他线程修改过么？
2. ABA问题
    1. 如果在两次读取期间，它的值曾经被改成B
    2. 后来又被改回A
    3. CAS操作就会误认为它从来没有改变过
3. 通过版本控制
    1. java.util.concurrent包提供了带有标记的原子引用类，通过控制版本来保证CAS正确性
    2. 不过目前来说，这个类比较"鸡肋"
    3. 大部分情况下ABA问题，并不会影响程序并发的正确性
    4. 如需要解决ABA问题，改用传统的互斥同步可能会比原子类效率更高。

##### 无同步方案

> 要保证线程安全，并不是一定就要进行同步，两者没有因果关系

```
同步只是保证共享数据争用时的正确性手段。
如果一个方法本来就不涉及共享数据，那它自然就无需任何同步措施去保证正确性。
```

因此有些代码天生就是线程安全的：
1. 可重入代码(Reentrant Code)：
    * 这种代码也叫作纯代码(Pure Code)
        * 可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)
        * 而在控制权返回后，原来的程序不会出现任何错误
    * 对线程安全来说，可重入性是更基本的特性
        * 它可以保证线程安全：即所有的可重入的代码都是线程安全的
        * 但并非所有线程安全的代码都是可重入的
    * 可重入代码有一些共同特征，如：
        1. 不依赖存储在堆上的数据和公用的系统资源
        2. 用到的状态量都由参数中传入
        3. 不调用非可重入的方法等
    * 判断可重入性的简单原则：
        * 如果一个方法，它的返回结果时可以预测的
        * 只要输入了相同的数据，就都能返回相同的结果
        * 那它就满足可重入性的要求，当然也就是线程安全的
2. 线程本地存储(Thread Local Storage)：
    * 如果一段代码中锁需要的数据，必须与其他代码共享
        * 那就看这些共享数据的代码，是否能保证在同一个线程中执行
        * 如果能：我们就可以把共享数据的可见范围，限制在同一个线程内
        * 这样，无需同步，也能保证线程之间不出现数据争用的问题
    * java.lang.ThreadLocal